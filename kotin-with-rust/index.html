<!DOCTYPE html>
<html lang="en">

<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
    <title>
Integrating Rust Libraries in Android &middot; siwu&#x27;s blog
</title>
    <link rel="stylesheet" href="https://gaxxx.github.io/slim.css">
    
    
</head>

<body>
    <div class="container">
        
<div class="header">
    <h1 class="site-title"><a href="https:&#x2F;&#x2F;gaxxx.github.io">siwu&#x27;s blog</a></h1>
    <input id="search" class=".next" type="search" placeholder="Search" />
    <p class="site-tagline"></p>
    <div class="nav">
        <a class="nav-btn" href="#">
            <span class="ci ci-burger"></span>
        </a>
        <ul class="nav-list">
            
            
            <li><a href="https:&#x2F;&#x2F;gaxxx.github.io&#x2F;tags">Tags</a></li>
            
            
            <li class="spacer">&ac;</li>
            
            
            <li><a href="https://www.linkedin.com/in/gaxxx">LinkedIn</a></li>
            
            <li><a href="https://github.com/gaxxx">Github</a></li>
            
            
        </ul>
    </div>
    <div class="search-results">
    <ul class="search-results__items"></ul>
    </div>

</div>

        <div class="content">
            <div class="posts">
                
<div class="post">
    
    
<h2 class="post-title"><a href="https:&#x2F;&#x2F;gaxxx.github.io&#x2F;kotin-with-rust&#x2F;">Integrating Rust Libraries in Android</a></h2>
<div class="post-header">
    <span class="post-date">November 22, 2021</span>
    
    <div class="post-tags">
        
        <span class="post-tag">#<a href="https://gaxxx.github.io/tags/rust/">rust</a></span>
        
        <span class="post-tag">#<a href="https://gaxxx.github.io/tags/android/">Android</a></span>
        
    </div>
    
</div>

    

  
    
  
    
    <a class="lang-toggle" href="https:&#x2F;&#x2F;gaxxx.github.io&#x2F;zh&#x2F;kotin-with-rust&#x2F;">
      中文
    </a>
    
  


    <div class="post-content">
        <p>This article introduces how to integrate a Rust library into an Android project.</p>
<span id="continue-reading"></span><h2 id="background">Background</h2>
<p>Recently while looking at high-performance KV stores for Android, I had an idea: find a high-performance Rust KV store, integrate it into an Android project, and call it via JNI. Simple, right? Then I stepped right into a pit.</p>
<p><a rel="external" href="https://github.com/gaxxx/KotlinRustProto">Code is here</a></p>
<p>JNI is a very mature mechanism, and exporting C functions from Rust is very reliable, so the implementation is straightforward. The questions to consider are:</p>
<ol>
<li>How to conveniently add new interfaces</li>
<li>How to log native code errors</li>
<li>How to optimize performance</li>
</ol>
<h2 id="implementation">Implementation</h2>
<ol>
<li>Complete a simple JNI call</li>
<li>Add protobuf support</li>
<li>Better protobuf encapsulation</li>
<li>Integrate LMDB</li>
<li>Tuning</li>
<li>MMKV</li>
</ol>
<h3 id="implementing-a-simple-jni-call">Implementing a Simple JNI Call</h3>
<ul>
<li>Define two functions in Kotlin - one returns a value, one takes a callback.
These functions load the lib file librsdroid.so</li>
</ul>
<pre><code>package com.linkedin.android.rsdroid;

import com.linkedin.android.rpc.NativeImpl

class RustCore {
    external fun greeting(): String
    external fun callback(cb : Callback)
    init {
        System.loadLibrary(&quot;rsdroid&quot;)
    }

    interface Callback {
        fun onSuccess()
    }
}

</code></pre>
<ul>
<li>Implement the corresponding functions in Rust:</li>
</ul>
<pre><code>#[no_mangle]
// Note: function names must correspond to the Kotlin class
pub unsafe extern fn Java_com_linkedin_android_rsdroid_RustCore_greeting(env: JNIEnv, _: JClass) -&gt; jstring {
    let world_ptr = CString::new(&quot;Hello world from Rust world&quot;).unwrap();
    let output = env.new_string(world_ptr.to_str().unwrap()).expect(&quot;Couldn&#39;t create java string!&quot;);
    output.into_inner()
}

#[no_mangle]
pub unsafe extern fn Java_com_linkedin_android_rsdroid_RustCore_callback(
    env: JNIEnv,
    _class: JClass,
    callback: JObject,
) {
    env.call_method(callback, &quot;onSuccess&quot;, &quot;()V&quot;, &amp;[])
        .unwrap();
}

</code></pre>
<p>The important thing is that Rust function signatures must match the Kotlin class. When calling Kotlin callbacks from Rust, check the corresponding function signatures (compile with kotlinc RustCore.kt and check the .class file, removing the ^A^C etc.)</p>
<pre><code> onSuccess^A^@^C()V^A^@^QL
</code></pre>
<ul>
<li>Compile Rust into librsdroid.so and add it to the Kotlin project. The cumbersome way is to first compile NDK toolchains, then compile arm, arm64, x86 versions of librsdroid.so, and place them in the Android project. There's now a simpler way with the plugin <a rel="external" href="https://github.com/mozilla/rust-android-gradle">org.mozilla.rust-android-gradle.rust-android</a></li>
</ul>
<pre><code>android {
...
ndkVersion &quot;22.1.7171670&quot;
...
}

apply plugin: &quot;org.mozilla.rust-android-gradle.rust-android&quot;

cargo {
    module = &quot;../rslib-bridge&quot;
    libname = &quot;rsdroid&quot;
    targets = [&quot;x86&quot;, &quot;arm&quot;, &quot;arm64&quot;]
    profile = &#39;release&#39;
    prebuiltToolchains = true
    apiLevel = 21
    verbose = true
}
</code></pre>
<p>This completes the JNI call - very straightforward. But the current approach has issues:</p>
<ul>
<li>Can only pass int, String, and similar types</li>
<li>Must get function parameters and callbacks right, or it may crash</li>
</ul>
<p>Using a fixed protocol, we can conveniently solve these issues. Protobuf is a suitable solution.</p>
<h3 id="adding-protobuf-to-the-project">Adding Protobuf to the Project</h3>
<p>Protobuf is also a very mature project. Given a proto file, both Rust and Java can generate appropriate code, but making them work together is the challenge.</p>
<p>First write a proto file defining an RPC service:</p>
<pre><code>syntax = &quot;proto3&quot;;

package Proto;
option java_package = &quot;com.linkedin.android.proto&quot;;

service DroidBackendService {
    rpc Hello(HelloIn) returns (HelloOut);
    rpc Sink(Empty) returns (Empty);
}

message HelloIn{
    int32 arg = 1;
}

message HelloOut{
    sint32 ret = 1;
    repeated string msg = 2;
}

message Empty {}
</code></pre>
<ul>
<li>Add protobuf support in Rust.
By importing <a rel="external" href="https://github.com/tokio-rs/prost">prost</a>, generate the template trait: DroidBackendService.
This ensures input/output is all []byte, with methods encapsulated in run_command_bytes2_inner_ad:</li>
</ul>
<pre><code>use prost::Message;
pub type BackendResult&lt;T&gt; = anyhow::Result&lt;T&gt;;
pub trait DroidBackendService {
    fn run_command_bytes2_inner_ad(&amp;self, method: u32, input: &amp;[u8]) -&gt; BackendResult&lt;Vec&lt;u8&gt;&gt; {
        match method {
            1 =&gt; {
                let input = HelloIn::decode(input)?;
                let output = self.hello(input)?;
                let mut out_bytes = Vec::new();
                output.encode(&amp;mut out_bytes)?;
                Ok(out_bytes)
            }
            2 =&gt; {
                let input = Empty::decode(input)?;
                let output = self.sink(input)?;
                let mut out_bytes = Vec::new();
                output.encode(&amp;mut out_bytes)?;
                Ok(out_bytes)
            }
            _ =&gt; Err(anyhow::anyhow!(&quot;invalid command&quot;)),
        }
    }
    fn hello(&amp;self, input: HelloIn) -&gt; BackendResult&lt;HelloOut&gt;;
    fn sink(&amp;self, input: Empty) -&gt; BackendResult&lt;Empty&gt;;
}
</code></pre>
<p>Then define the concrete service implementation:</p>
<pre><code>pub struct Backend {
}

impl Backend {
    pub fn new() -&gt; Backend {
        Backend{}
    }
}

impl DroidBackendService for Backend {
    fn hello(&amp;self, input: HelloIn) -&gt; BackendResult&lt;HelloOut&gt; {
        Ok(HelloOut {
            ret: input.arg,
            msg : (0..input.arg).map(|_| &quot;hello&quot;.to_owned()).collect(),
        })
    }

    fn sink(&amp;self, input: Empty) -&gt; BackendResult&lt;Empty&gt; {
        Ok(Empty{})
    }
}
</code></pre>
<p>Finally, export the service as a single function:</p>
<pre><code>#[no_mangle]
pub unsafe extern fn Java_com_linkedin_android_rsdroid_RustCore_run(
    env: JNIEnv,
    _: JClass,
    command: jint,
    args: jbyteArray,
    cb : JObject,
) {
    let mut backend = Backend::new();

    let result = catch_unwind(AssertUnwindSafe(|| {
        let command: u32 = command as u32;
        let in_bytes = env.convert_byte_array(args).unwrap();
        return backend.run_command_bytes2_inner_ad(command, &amp;in_bytes);
    }));

    if cb.into_inner().is_null() {
        return
    }

    match result {
        Ok(Ok(_s)) =&gt; {
            let data = env.byte_array_from_slice(&amp;_s).unwrap();
            env.call_method(cb, &quot;onSuccess&quot;, &quot;([B)V&quot;, &amp;[data.into()]);
            return
        }
        _ =&gt; {
            let world_ptr = CString::new(&quot;error&quot;).unwrap();
            let output = env.new_string(world_ptr.to_str().unwrap()).expect(&quot;Couldn&#39;t create java string!&quot;);
            env.call_method(cb, &quot;onErr&quot;, &quot;(ILjava/lang/String;)V&quot;, &amp;[10.into(), output.into()]);
            return;
        }
    }
}
</code></pre>
<p>Now Java can pass protobuf data and receive protobuf callbacks.
To generate corresponding Java classes, use <a rel="external" href="https://github.com/google/protobuf-gradle-plugin">protobuf-gradle-plugin</a>:</p>
<pre><code>def droidProtobufFolder = new File(rootDir, &quot;rslib-bridge/proto&quot;).getAbsolutePath()

## Configure proto file path
android {
    sourceSets {
        main {
            proto {
                srcDir droidProtobufFolder
            }
        }
    }
}


## Generate Java classes
protobuf {
    plugins {
        javalite {
            artifact = &#39;com.google.protobuf:protoc-gen-javalite:3.0.0&#39;
        }
    }
    protoc {
        artifact = &#39;com.google.protobuf:protoc:3.8.0&#39;
    }
    // this is a task which wil generate classes for our proto files
    generateProtoTasks {
        all().each { task -&gt;
            task.builtins {
                remove java
            }
            task.plugins {
                javalite {}
            }
        }
    }
}

</code></pre>
<p>Now we can call it in code:</p>
<pre><code>val builder = AdBackend.HelloIn.newBuilder();
val arg = builder.setArg(1000).build();
RustCore.instance.run(1, arg.toByteArray(), object : ProtoCallback {
    override fun onErr(code: Int, msg: String) {
        Log.d(&quot;MainActivity&quot;, &quot;msg&quot;);
    }

    override fun onSuccess(out: ByteArray) {
        val helloOut = AdBackend.HelloOut.parseFrom(out);
        Log.d(&quot;MainActivity&quot;, helloOut.toString());
    }
});
</code></pre>
<p>This completes the Kotlin and Rust interaction. But there's still one question: why pass cmd_number? Can't we encapsulate the method number like in Java and Rust?</p>
<h3 id="better-protobuf-encapsulation">Better Protobuf Encapsulation</h3>
<p>Good news - we can adjust generated Java classes through a custom protobuf plugin:</p>
<pre><code>protobuf {
    // Python script path
    String protocGenPath = OperatingSystem.current().isWindows() ? &#39;tools\\protoc-gen\\protoc-gen.bat&#39; : &#39;tools/protoc-gen/protoc-gen.sh&#39;
    File f = new File(project.rootDir, protocGenPath)
    if (!f.exists()) {
        throw new IllegalStateException(&quot;&#39;${f.absolutePath}&#39; does not exist&quot;)
    }

    //  Custom plugin
    plugins {
        // Define a plugin with name &#39;anki&#39;.
        native_rpc { path = f.absolutePath }
    }

    // this is a task which wil generate classes for our proto files
    generateProtoTasks {
        all().each { task -&gt;
            // Execute plugin to parse proto files
            task.plugins {
                native_rpc {}
            }
        }
    }
</code></pre>
<p>Then through a custom Python script, we can auto-generate commands:</p>
<pre><code>package com.linkedin.android.rpc;

import java.lang.annotation.Retention;
import androidx.annotation.IntDef;
import java.lang.annotation.RetentionPolicy;
import androidx.annotation.Nullable;
@IntDef ({
NativeMethods.HELLO,
NativeMethods.SINK
})
public @interface NativeMethods {
    int HELLO = 1;
    int SINK = 2;
}

</code></pre>
<p>Now we can call using cmd:</p>
<pre><code>RustCore.instance.run(NativeMethods.SINK, Native.Empty.getDefaultInstance().toByteArray(), null);

</code></pre>
<p>Or encapsulate it more thoroughly, generating code like:</p>
<pre><code>
public abstract class NativeImpl {

protected abstract void executeCommand(final int command, byte[] args, RustCore.ProtoCallback cb);

// Auto-generated code
public void hello(Native.HelloIn args, RustCore.Callback&lt;Native.HelloOut&gt; cb) {
    byte[] result = null;
    executeCommand(1, args.toByteArray(), new RustCore.ProtoCallback() {
        @Override
        public void onErr(int code, @NonNull String msg) {
            cb.onErr(code, msg);
        }
        @Override
        public void onSuccess(@NonNull byte[] out) {
            Native.HelloOut message = null;
            try {
                message = Native.HelloOut.parseFrom(out);
            } catch (InvalidProtocolBufferException e) {
                e.printStackTrace();
            }
            cb.onSuccess(message);
        }
    });
    }
}

</code></pre>
<p>Then wrap it with a helper:</p>
<pre><code> public abstract class NativeImpl
 inner class NativeHelp : NativeImpl() {
        override fun executeCommand(command: Int, args: ByteArray?, cb: ProtoCallback?) {
            run(command, args!!, cb);
        }
    }
</code></pre>
<p>And call it conveniently (sort of):</p>
<pre><code>RustCore.navHelper.hello(
            Native.HelloIn.newBuilder()
                .setArg(10).build(),
            object : RustCore.Callback&lt;Native.HelloOut&gt; {
            override fun onErr(code: Int, msg: String) {
                Log.d(&quot;MainActivity&quot;, &quot;msg&quot;);
            }

            override fun onSuccess(arg: Native.HelloOut) {
                Log.d(&quot;MainActivity&quot;, arg.toString());
            }
        });
</code></pre>
<p>But this approach has some issues:</p>
<ol>
<li>cmd_number is fixed</li>
<li>No way to implement zerocopy</li>
<li>Support for multiple proto files requires modifying both Java plugin and Rust custom build</li>
</ol>
<p>These can be optimized gradually, but we can start testing LMDB integration...</p>
<h3 id="integrating-lmdb">Integrating LMDB</h3>
<p>Integrating a KV store is completely transparent to Java, so I integrated both LMDB and Sled simultaneously. Just implement the DroidBackendService trait:</p>
<pre><code>fn open(&amp;self, input: Str) -&gt; BackendResult&lt;Resp&gt; {
        match useEnd {
            End::LMDB=&gt; {
                lmdb::open(Path::new(&amp;input.val))
            }
            End::SLED =&gt; {
                db::open(Path::new(&amp;input.val));
            }
            _ =&gt; {}
        }
        Ok(Resp{
            ret : 0,
            msg: &quot;&quot;.into(),
        })
    }
</code></pre>
<p>Note that all save and get operations must happen after open, but Rust has those pesky mutability checks. So I used locks to ensure proper store initialization, then used unsafe to modify statics.</p>
<pre><code>use once_cell::sync::Lazy;


static mut KV_STORE : Option&lt;Bucket&lt;Raw, Raw&gt;&gt; = None;
static KV_LOCK: Lazy&lt;RwLock&lt;bool&gt;&gt; = Lazy::new(|| RwLock::new(false));

pub fn open(path : &amp;Path) {
    let mut kv_lock = KV_LOCK.write().unwrap();
    if *kv_lock == true {
        panic!(&quot;already opened&quot;)
    }
    fs::create_dir_all(&amp;path).unwrap();
    let mut cfg = Config::new(path);
    let store = Store::new(cfg).unwrap();
    *kv_lock = true;
    unsafe {
        *KV_STORE.borrow_mut() = Some(Arc::new(store.bucket::&lt;Raw, Raw&gt;(None).unwrap()))
    }
}

</code></pre>
<p>Compilation was rough, running it was rough too... Since I was printing stack traces in Rust, I also introduced android_log to output logs to logcat:</p>
<pre><code># Cargo.toml
android_logger = &quot;0.10&quot;
log = &quot;0.4.14&quot;

# lib.rs

#[allow(non_snake_case)]
#[no_mangle]
pub extern &quot;system&quot; fn JNI_OnLoad(vm: JavaVM, _: *mut c_void) -&gt; jint {
    android_logger::init_once(Config::default().with_tag(&quot;RustNativeCore&quot;).with_min_level(log::Level::Trace));
    JNI_VERSION_1_6
}



...
let result = catch_unwind(AssertUnwindSafe(|| {
    panic::set_hook(Box::new(|_| {
        let backtrace = Backtrace::new();
        log::error!(&quot;ops: {:?}&quot;, backtrace);
    }));
    ...
}))
...

</code></pre>
<p>In logcat, I found the file path was wrong. After fixing it, everything worked.</p>
<p>But after all that effort, introducing Rust actually performed worse than SharedPreferences...</p>
<p>Disappointing, beyond my imagination.</p>
<table><thead><tr><th>Interface</th><th>Time for 1000 calls</th></tr></thead><tbody>
<tr><td>SharedPreference.set(String, String)</td><td>410ms</td></tr>
<tr><td>SharedPreference.get(String)</td><td>16ms</td></tr>
<tr><td>Native.Sled.set(String, String)</td><td>900ms</td></tr>
<tr><td>Native.Sled.get(String) : String</td><td>800ms</td></tr>
</tbody></table>
<h3 id="tuning">Tuning</h3>
<p>Thought it was the end, but work had just begun. I tried an empty interface:</p>
<pre><code>#[no_mangle]
pub unsafe extern fn Java_com_linkedin_android_rsdroid_RustCore_empty(env: JNIEnv, _: JClass) {
}

</code></pre>
<table><thead><tr><th>Interface</th><th>Time for 1000 calls</th></tr></thead><tbody>
<tr><td>Native.empty</td><td>1ms</td></tr>
</tbody></table>
<p>So the problem is in parameter passing. Even simple String read/write is quite expensive:</p>
<table><thead><tr><th>Interface</th><th>Time for 1000 calls</th></tr></thead><tbody>
<tr><td>Native.testStringGet() : String</td><td>129ms</td></tr>
<tr><td>Native.testStringSet(String)</td><td>28ms</td></tr>
</tbody></table>
<p>Following <a rel="external" href="https://developer.android.com/training/articles/perf-jni">JNI optimization</a> methods, the options are:</p>
<ol>
<li>Pass pointers directly (GetByteArrayElements)</li>
</ol>
<p>Get data via get_byte_array_elements:</p>
<pre><code>pub unsafe extern fn Java_com_linkedin_android_rsdroid_RustCore_testByte(env: JNIEnv, _: JClass, input : jbyteArray) {
    let input = env.get_byte_array_elements(input, ReleaseMode::NoCopyBack).unwrap();
}
</code></pre>
<p>Write data via set_byte_array_region:</p>
<pre><code>pub unsafe extern fn Java_com_linkedin_android_rsdroid_RustCore_testByte(env: JNIEnv, _: JClass,  output: jbyteArray) {
    let input = env.get_byte_array_elements(input, ReleaseMode::NoCopyBack).unwrap();
}
</code></pre>
<p>Doesn't seem to change much:</p>
<table><thead><tr><th>Interface</th><th>Time for 1000 calls</th></tr></thead><tbody>
<tr><td>Native.testByteArray(ByteArray) empty</td><td>2ms</td></tr>
<tr><td>Native.testByteArray(ByteArray)</td><td>100ms</td></tr>
<tr><td>Native.getByteArray(output : ByteArray)</td><td>170ms</td></tr>
</tbody></table>
<ol start="2">
<li>Pass byte buffers (ByteBuffer)</li>
</ol>
<p>Get parameter address directly via get_direct_buffer_address, but also no improvement:</p>
<table><thead><tr><th>Interface</th><th>Time for 1000 calls</th></tr></thead><tbody>
<tr><td>Native.testByteArray(ByteBuffer) empty</td><td>0ms</td></tr>
<tr><td>Native.testByteArray(ByteBuffer)</td><td>100ms</td></tr>
<tr><td>Native.getByteArray(output : ByteBuffer)</td><td>200ms</td></tr>
</tbody></table>
<p>So it seems any native read/write of Java data starts at 100ms...</p>
<p>At this point I was about to go bald and was ready to quietly delete this library. Then I tested on a real device, and the results were actually decent...</p>


<img src="https:&#x2F;&#x2F;gaxxx.github.io&#x2F;processed_images&#x2F;perf.0371c58abf31c39c.png" />
<p>Updates:</p>
<ul>
<li>I found I can get input parameter pointers directly in Rust, enabling faster protobuf parsing.</li>
<li>Using a similar approach, you can even achieve something like multiple return values in Java.</li>
<li>Added signature verification to prevent Rust lib and Java lib from being out of sync.</li>
</ul>
<ol>
<li>Rust stability is solid - no crashes, just compilation costs some hair</li>
<li>Sled is pretty strong - just slightly slower than memory. With a Java cache, it might fly. But not ready for production because:</li>
</ol>
<ul>
<li>Doesn't support multi-process</li>
<li>Sled writes to disk periodically (default 200ms), may lose tiny amounts of data...</li>
</ul>
<ol start="3">
<li>LMDB is decent but not as good as imagined. Usable.</li>
<li>For small KV operations, JNI overhead may be slightly too high, but for networking, it should perform better.</li>
<li>With protobuf, Rust can interact with other languages, so next time I might try Flutter.</li>
</ol>
<h3 id="mmkv">MMKV</h3>
<p>Thought I was done, but impulsively integrated MMKV. Got humbled. <a rel="external" href="https://github.com/Tencent/MMKV">MMKV</a>'s speed is basically on par with Java Map. After looking at their source code, I didn't see any black magic, then I discovered:</p>
<ol>
<li>Logging costs about 100ms</li>
<li>Protobuf encoding/decoding costs about 100ms</li>
</ol>
<p>So Sled and MMKV aren't that far apart after all. That's it.</p>
<p>References:</p>
<p><a rel="external" href="https://github.com/ankidroid/Anki-Android">Anki Android</a></p>
<p><a rel="external" href="https://developer.android.com/training/articles/perf-jni">JNI tips | Android NDK | Android Developers</a></p>
<p><a rel="external" href="https://www.sitepoint.com/rust-global-variables/#externallibraries">How to Idiomatically Use Global Variables in Rust - SitePoint</a></p>
<p><a rel="external" href="https://github.com/google/protobuf-gradle-plugin">google/protobuf-gradle-plugin: Protobuf Plugin for Gradle (github.com)</a></p>
<p><a rel="external" href="https://github.com/spacejam/sled/">spacejam/sled: the champagne of beta embedded databases (github.com)</a></p>
<p><a rel="external" href="https://docs.rs/jni/0.19.0/jni/index.html">jni - Rust (docs.rs)</a></p>
<p><a rel="external" href="https://developer.ibm.com/articles/j-jni/">Best practices for using the Java Native Interface</a></p>

    </div>
    
</div>

            </div>
            
        </div>
        
<div class="footer">
    
    <p>Powered by <a href="https://getzola.org">Zola</a></p>
    
</div>

    </div>
    <script src="https://gaxxx.github.io/js/slim.js"></script>
    <script src="https://gaxxx.github.io/js/elasticlunr.min.js"></script>
    <script src="https://gaxxx.github.io/search_index.en.js"></script>
    <script src="https://gaxxx.github.io/js/lunr.stemmer.support.js"></script>
    <script src="https://gaxxx.github.io/js/lunr.en.js"></script>
    <script src="https://gaxxx.github.io/js/search.js"></script>
    
</body>

</html>
