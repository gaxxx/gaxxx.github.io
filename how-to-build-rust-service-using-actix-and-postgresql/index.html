<!DOCTYPE html>
<html lang="en">

<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
    <title>
Building CRUD with Rust &middot; siwu&#x27;s blog
</title>
    <link rel="stylesheet" href="https://gaxxx.github.io/slim.css">
    
    
</head>

<body>
    <div class="container">
        
<div class="header">
    <h1 class="site-title"><a href="https:&#x2F;&#x2F;gaxxx.github.io">siwu&#x27;s blog</a></h1>
    <input id="search" class=".next" type="search" placeholder="Search" />
    <p class="site-tagline"></p>
    <div class="nav">
        <a class="nav-btn" href="#">
            <span class="ci ci-burger"></span>
        </a>
        <ul class="nav-list">
            
            
            <li><a href="https:&#x2F;&#x2F;gaxxx.github.io&#x2F;tags">Tags</a></li>
            
            
            <li class="spacer">&ac;</li>
            
            
            <li><a href="https://www.linkedin.com/in/gaxxx">LinkedIn</a></li>
            
            <li><a href="https://github.com/gaxxx">Github</a></li>
            
            
        </ul>
    </div>
    <div class="search-results">
    <ul class="search-results__items"></ul>
    </div>

</div>

        <div class="content">
            <div class="posts">
                
<div class="post">
    
    
<h2 class="post-title"><a href="https:&#x2F;&#x2F;gaxxx.github.io&#x2F;how-to-build-rust-service-using-actix-and-postgresql&#x2F;">Building CRUD with Rust</a></h2>
<div class="post-header">
    <span class="post-date">July 09, 2020</span>
    
    <div class="post-tags">
        
        <span class="post-tag">#<a href="https://gaxxx.github.io/tags/rust/">rust</a></span>
        
        <span class="post-tag">#<a href="https://gaxxx.github.io/tags/crud/">crud</a></span>
        
    </div>
    
</div>

    

  
    
  
    
    <a class="lang-toggle" href="https:&#x2F;&#x2F;gaxxx.github.io&#x2F;zh&#x2F;how-to-build-rust-service-using-actix-and-postgresql&#x2F;">
      中文
    </a>
    
  


    <div class="post-content">
        <p>This is the first article in the Rust series.</p>
<p>While Rust is known for its high performance, for simple CRUD we usually prefer Spring Boot or Go. But it's not impossible with Rust either.</p>
<p>Code available at:
https://github.com/gaxxx/rust-crud</p>
<span id="continue-reading"></span><h2 id="dependencies">Dependencies</h2>
<ul>
<li>postgresql</li>
<li>rust</li>
<li>vscode</li>
</ul>
<h2 id="initialization-git-checkout-step0">Initialization (git checkout step0)</h2>
<ul>
<li>Create initial project</li>
</ul>
<ol>
<li>cargo new hero-api</li>
<li>Add dependencies to cargo.toml</li>
</ol>
<pre><code>actix-web=&quot;2.0.0&quot;
actix-rt = &quot;1.0&quot;
</code></pre>
<ol start="3">
<li>Try the initial file</li>
</ol>
<pre><code>use actix_web::{web, App, Responder, HttpServer, get};

#[get(&quot;/{username}&quot;)]
async fn hello(user : web::Path&lt;String&gt; ) -&gt; impl Responder {
    format!(&quot;Hello world {}&quot;, user.into_inner())
}


#[actix_rt::main]
async fn main() -&gt; std::io::Result&lt;()&gt; {
    HttpServer::new(move || {
        App::new()
            .service(
                web::scope(&quot;/hello&quot;)
                    .service(hello)
            )
    })
        .bind(&quot;127.0.0.1:8088&quot;)?
        .run()
        .await
}
</code></pre>
<ol start="4">
<li>Create an api.http file, add tests, install REST Client plugin</li>
</ol>
<pre><code>GET http://127.0.0.1:8088/hello/test
</code></pre>
<h2 id="add-json-support-git-checkout-json">Add JSON Support (git checkout json)</h2>
<ol>
<li>Add serde to cargo.toml</li>
<li>Define a struct - serialization and deserialization via derive:</li>
</ol>
<pre><code>#[derive(Deserialize, Debug, Clone)]
struct Info {
    username : String
}

#[get(&quot;/{username}&quot;)]
async fn hello(user : web::Path&lt;Info&gt; ) -&gt; impl Responder {
    format!(&quot;Hello world {}&quot;, user.username)
}
</code></pre>
<h2 id="add-database-support-git-checkout-db">Add Database Support (git checkout db)</h2>
<ol>
<li>Add diesel to Cargo.toml:</li>
</ol>
<pre><code>diesel = { version = &quot;1.0.0&quot;, features = [&quot;postgres&quot;] }
dotenv = &quot;0.9.0&quot;
r2d2-diesel = &quot;1.0.0&quot;
</code></pre>
<ol start="2">
<li>Install diesel CLI:</li>
</ol>
<pre><code>cargo install diesel_cli --no-default-features --features postgres
</code></pre>
<ol start="3">
<li>Configure PostgreSQL:</li>
</ol>
<pre><code># Create database
sudo -u postgres psql
ALTER USER postgres PASSWORD &#39;password&#39;;
create database heroes;

# Write connection string to .env file
echo DATABASE_URL=postgres://postgres:password@127.0.0.1/heroes &gt; .env


# Generate database tables
disel setup
// generate module tables
diesel migration generate heroes


# If it fails, add to pg_hba.conf:
host    all             all             127.0.0.1/32            md5

# Configure the database table, see rust-crud for details
# Generate diesel schema
diesel migration run

# File contents - diesel generates many macros for this structure

table! {
    users (id) {
        id -&gt; Int4,
        name -&gt; Varchar,
        identity -&gt; Varchar,
        hometown -&gt; Varchar,
        age -&gt; Int4,
    }
}

</code></pre>
<ol start="5">
<li>Add DB:</li>
</ol>
<pre><code>

# Get DB from request
impl FromRequest for DB {
    type Error = ();
    type Future = LocalBoxFuture&lt;&#39;static, Result&lt;Self, Self::Error&gt;&gt;;
    type Config = DB;

    fn from_request(req: &amp;HttpRequest, _: &amp;mut Payload&lt;PayloadStream&gt;) -&gt; Self::Future {
        let config= req.app_data::&lt;Self::Config&gt;().unwrap();
        futures::future::ok(config.clone()).boxed_local()
    }
}

# Add connection pool
pub type Pool = r2d2::Pool&lt;ConnectionManager&lt;PgConnection&gt;&gt;;
#[derive(Clone)]
pub struct DB(pub Pool);
</code></pre>
<ol start="6">
<li>Add DB to the router layer:</li>
</ol>
<pre><code># Add DB to App
App::new()
            .app_data(db::DB::default())

# In handlers, DB is available directly since FromRequest is implemented
#[post(&quot;/&quot;)]
async fn create(hero: web::Json&lt;hero::HeroInput&gt;, db: db::DB) -&gt; impl Responder {
    let created : hero::Hero = diesel::insert_into(schema::users::table)
        .values(hero.into_inner())
        .get_result(db.get().deref()).expect(&quot;Error creagint&quot;);
    println!(&quot;output is {:?}&quot;, created);
    web::Json(created)
}
</code></pre>
<ol start="7">
<li>Diesel provides support for all CRUD operations:</li>
</ol>
<pre><code>// create
diesel::insert_into(schema::users::table)
        .values(hero.into_inner())
// read
users.filter(id.eq(update_id.into_inner()))
        .first::&lt;hero::Hero&gt;(&amp;*db.get());
// update
diesel::update(users.filter(id.eq(update_id.into_inner())))
        .set(hero.into_inner())
// delete
diesel::delete(users.filter(id.eq(update_id.into_inner())))


//list
users.load::&lt;hero::Hero&gt;(&amp;*db.get()).unwrap();
</code></pre>
<h2 id="add-pagination-support-git-checkout-master">Add Pagination Support (git checkout master)</h2>
<pre><code># Define a pagination trait
pub trait Paginate: Sized {
    fn paginate(self, start: i64) -&gt; Paginated&lt;Self&gt;;
}

# Extend query results from returning a single row to returning a (data, total_count) tuple
impl&lt;T: Query&gt; Query for Paginated&lt;T&gt; {
    type SqlType = (T::SqlType, BigInt);
}

# Implement query

impl&lt;T&gt; QueryFragment&lt;Pg&gt; for Paginated&lt;T&gt;
    where
        T: QueryFragment&lt;Pg&gt;,
{
    fn walk_ast(&amp;self, mut out: AstPass&lt;Pg&gt;) -&gt; QueryResult&lt;()&gt; {
        out.push_sql(&quot;SELECT *, COUNT(*) OVER () FROM (&quot;);
        self.query.walk_ast(out.reborrow())?;
        out.push_sql(&quot;) t LIMIT &quot;);
        out.push_bind_param::&lt;BigInt, _&gt;(&amp;self.count)?;
        out.push_sql(&quot; OFFSET &quot;);
        let offset = self.start;
        out.push_bind_param::&lt;BigInt, _&gt;(&amp;offset)?;
        Ok(())
    }
}

# Usage in the handler
#[get(&quot;/&quot;)]
async fn gets(req : web::Query&lt;PageRequest&gt; ,db : db::DB) -&gt; impl Responder {
    use schema::users::dsl::*;
    use crate::db::pagination::Paginate;
    let query = users.order(id.asc());
    let query = query.paginate(req.start.unwrap_or(0).into());
    let all_users : Vec&lt;_&gt; = query.load::&lt;(hero::Hero, i64)&gt;(&amp;*db.get()).unwrap();
    web::Json(all_users.iter().map(|v| v.0.clone()).collect::&lt;Vec&lt;_&gt;&gt;())
}
</code></pre>
<h2 id="thoughts">Thoughts</h2>
<ol>
<li>Diesel is different from other ORMs - it's implemented through macros at the bottom level, with fairly complete support for various queries</li>
<li>Performance-wise, it just delivers</li>
<li>Reminds me of when I first started with Go, when beego had just come out and Bitcoin was still super cheap...</li>
</ol>
<h2 id="references">References</h2>
<p>https://medium.com/sean3z/building-a-restful-crud-api-with-rust-1867308352d8</p>

    </div>
    
</div>

            </div>
            
        </div>
        
<div class="footer">
    
    <p>Powered by <a href="https://getzola.org">Zola</a></p>
    
</div>

    </div>
    <script src="https://gaxxx.github.io/js/slim.js"></script>
    <script src="https://gaxxx.github.io/js/elasticlunr.min.js"></script>
    <script src="https://gaxxx.github.io/search_index.en.js"></script>
    <script src="https://gaxxx.github.io/js/lunr.stemmer.support.js"></script>
    <script src="https://gaxxx.github.io/js/lunr.en.js"></script>
    <script src="https://gaxxx.github.io/js/search.js"></script>
    
</body>

</html>
